#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Deny List reader for FlatBuffers (Python)
- รองรับไฟล์ไบนารีปกติ และกรณีบีบอัดแบบ deflate/zlib
- รองรับไฟล์ .zip ที่มี .bin ข้างใน (จะเลือกไฟล์ .bin ไฟล์แรกโดยอัตโนมัติ)
- สร้าง reason lookup และ index ด้วย surrogate PAN
- CLI: --list, --pan, --stats, --export-csv, --export-json, --suppress-id-warn
"""

from __future__ import annotations
import argparse
import inspect
import sys
import zlib
import zipfile
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple
from collections import Counter
import csv
import json

# === Generated by: flatc --python denyList.fbs ===
# จะมีโฟลเดอร์ TransCity/ หรือไฟล์ .py อยู่รากโปรเจกต์ ขึ้นกับ namespace ใน .fbs
try:
    from TransCity.DenyList import DenyList
    from TransCity.DenyListEntry import DenyListEntry
    from TransCity.DenyReason import DenyReason
except ModuleNotFoundError:
    # fallback: เผื่อ generate โดยไม่มี namespace TransCity;
    from DenyList import DenyList  # type: ignore
    from DenyListEntry import DenyListEntry  # type: ignore
    from DenyReason import DenyReason  # type: ignore


# ------------------------------
# Data structures
# ------------------------------
@dataclass
class DenyEntry:
    surrogate_pan: str
    removed_present: bool
    removed: bool
    reason_ids: List[int]
    reason_labels: List[str]


@dataclass
class DenyListModel:
    reasons: Dict[int, str]
    entries_by_pan: Dict[str, DenyEntry]


# ------------------------------
# Helpers
# ------------------------------
def _maybe_inflate(data: bytes) -> bytes:
    """
    พยายามคลายบีบอัด:
      1) raw deflate (wbits=-MAX_WBITS)
      2) zlib wrapper
    ถ้าคลายไม่ได้ ให้คืนค่าเดิม
    """
    # raw deflate
    try:
        return zlib.decompress(data, -zlib.MAX_WBITS)
    except zlib.error:
        pass
    # zlib wrapper
    try:
        return zlib.decompress(data)
    except zlib.error:
        return data


def _read_first_bin_in_zip(zip_path: str) -> bytes:
    with zipfile.ZipFile(zip_path, "r") as zf:
        names = zf.namelist()
        target = next((n for n in names if n.lower().endswith(".bin")), names[0] if names else None)
        if not target:
            raise FileNotFoundError("ZIP is empty.")
        with zf.open(target, "r") as f:
            return f.read()


def _load_bytes_from_path(path: str) -> bytes:
    data: bytes
    if path.lower().endswith(".zip"):
        data = _read_first_bin_in_zip(path)
    else:
        with open(path, "rb") as f:
            data = f.read()
    return _maybe_inflate(data)


def _b2s(x) -> str:
    if isinstance(x, (bytes, bytearray, memoryview)):
        return bytes(x).decode("utf-8", errors="replace")
    return x if isinstance(x, str) else str(x)


def _vec_get(getter, idx: int, cls):
    """
    รองรับทั้ง 2 สไตล์ของโค้ดที่ flatc สร้าง:
      - getter(obj, idx) -> obj  (เวอร์ชันเก่า: ต้องส่ง instance เข้าไป)
      - getter(idx) -> obj       (เวอร์ชันใหม่: คืน obj ตรง)
    """
    try:
        sig = inspect.signature(getter)
        if len(sig.parameters) == 2:
            obj = cls()
            res = getter(obj, idx)
            return obj if res is None else res
        return getter(idx)
    except TypeError:
        try:
            return getter(idx)
        except TypeError:
            obj = cls()
            getter(obj, idx)
            return obj


# ------------------------------
# Parsing FlatBuffer
# ------------------------------
def parse_denylist_bytes(data: bytes, suppress_id_warn: bool = False) -> DenyListModel:
    mv = memoryview(data)

    # เตือนถ้า file_identifier ไม่ตรง (ถ้ามีตั้งไว้ใน .fbs)
    try:
        has_id_fn = getattr(DenyList, "DenyListBufferHasIdentifier", None)
        if callable(has_id_fn):
            if not has_id_fn(mv, 0) and not suppress_id_warn:
                print(
                    "[WARN] Buffer file_identifier mismatch (expected schema identifier). Continuing parse anyway.",
                    file=sys.stderr,
                )
    except Exception:
        pass

    root = DenyList.GetRootAsDenyList(mv, 0)

    # --- reasons lookup ---
    reasons: Dict[int, str] = {}
    length_reasons = getattr(root, "DenyReasonsLength", lambda: 0)()
    for i in range(length_reasons):
        r = _vec_get(root.DenyReasons, i, DenyReason)
        rid = int(r.Id())
        reasons[rid] = _b2s(r.Value())

    # --- entries index ---
    entries_by_pan: Dict[str, DenyEntry] = {}
    length_entries = getattr(root, "DenyListEntriesLength", lambda: 0)()
    for i in range(length_entries):
        e = _vec_get(root.DenyListEntries, i, DenyListEntry)

        # เมธอดอาจเป็น SurrogatePAN() หรือ SurrogatePan() แล้วแต่ชื่อฟิลด์ใน .fbs
        get_pan = getattr(e, "SurrogatePAN", None) or getattr(e, "SurrogatePan", None)
        if not get_pan:
            raise AttributeError("DenyListEntry has no SurrogatePAN/SurrogatePan()")
        pan = _b2s(get_pan())

        ids = [int(e.DenyReasonsId(j)) for j in range(e.DenyReasonsIdLength())]
        labels = [reasons.get(x, f"UNKNOWN({x})") for x in ids]

        # presence ของ optional bool (ถ้า schema ใช้ default แทน optional ก็จะ present=false เสมอ)
        removed_present = False
        removed_val = False
        if hasattr(e, "RemovedIsNone") and callable(getattr(e, "RemovedIsNone")):
            removed_present = not e.RemovedIsNone()
            removed_val = bool(e.Removed()) if removed_present else False
        else:
            removed_val = bool(e.Removed())

        entries_by_pan[pan] = DenyEntry(
            surrogate_pan=pan,
            removed_present=removed_present,
            removed=removed_val,
            reason_ids=ids,
            reason_labels=labels,
        )

    return DenyListModel(reasons=reasons, entries_by_pan=entries_by_pan)


# ------------------------------
# Public API
# ------------------------------
def load_denylist(path_or_bytes: str | bytes, suppress_id_warn: bool = False) -> DenyListModel:
    if isinstance(path_or_bytes, (bytes, bytearray, memoryview)):
        data = _maybe_inflate(bytes(path_or_bytes))
    else:
        data = _load_bytes_from_path(path_or_bytes)
    return parse_denylist_bytes(data, suppress_id_warn=suppress_id_warn)


def is_denied(model: DenyListModel, surrogate_pan: str) -> Tuple[bool, Optional[DenyEntry]]:
    entry = model.entries_by_pan.get(surrogate_pan)
    return (entry is not None), entry


# ------------------------------
# Export / Stats
# ------------------------------
def _entry_to_row(e: DenyEntry) -> Dict[str, str]:
    return {
        "pan": e.surrogate_pan,
        "removed": "true" if e.removed else "false",
        "removed_present": "true" if e.removed_present else "false",
        "reason_ids": ",".join(str(x) for x in e.reason_ids),
        "reason_labels": ",".join(e.reason_labels),
    }


def write_csv(path: str, model: DenyListModel) -> None:
    rows = [_entry_to_row(e) for e in model.entries_by_pan.values()]
    fieldnames = ["pan", "removed", "removed_present", "reason_ids", "reason_labels"]
    with open(path, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames)
        w.writeheader()
        w.writerows(rows)


def write_json(path: str, model: DenyListModel) -> None:
    out = {
        "reasons": {int(k): v for k, v in model.reasons.items()},
        "entries": [_entry_to_row(e) for e in model.entries_by_pan.values()],
    }
    with open(path, "w", encoding="utf-8") as f:
        json.dump(out, f, ensure_ascii=False, indent=2)


def print_stats(model: DenyListModel) -> None:
    total = len(model.entries_by_pan)
    # นับตาม reason id (ตัวนึงอาจมีหลายเหตุผล จึงนับแบบรวม)
    c = Counter()
    for e in model.entries_by_pan.values():
        c.update(e.reason_ids)
    print(f"Total entries: {total}")
    print("Counts by reason id:")
    for rid, cnt in sorted(c.items()):
        label = model.reasons.get(rid, f"UNKNOWN({rid})")
        print(f"  {rid:>3}  {label:<16}  {cnt}")
    # นับ removed
    removed_true = sum(1 for e in model.entries_by_pan.values() if e.removed)
    print(f"Removed=true: {removed_true}")
    print(f"Removed=false: {total - removed_true}")


# ------------------------------
# CLI
# ------------------------------
def _fmt_entry(e: DenyEntry) -> str:
    rem = f"{'present' if e.removed_present else 'absent'} -> {'true' if e.removed else 'false'}"
    return (
        f"PAN={e.surrogate_pan} | removed({rem}) | "
        f"reason_ids={e.reason_ids} | reasons={e.reason_labels}"
    )


def main():
    parser = argparse.ArgumentParser(description="Read/Query Deny List (FlatBuffers).")
    parser.add_argument("input", help="path to .bin or .zip (deflate/zlib supported)")
    parser.add_argument("--pan", help="surrogate PAN to check (exact match)")
    parser.add_argument("--list", action="store_true", help="print all entries")
    parser.add_argument("--stats", action="store_true", help="show summary stats")
    parser.add_argument("--export-csv", metavar="PATH", help="export entries to CSV")
    parser.add_argument("--export-json", metavar="PATH", help="export entries+reasons to JSON")
    parser.add_argument("--suppress-id-warn", action="store_true", help="suppress file_identifier mismatch warning")
    args = parser.parse_args()

    model = load_denylist(args.input, suppress_id_warn=args.suppress_id_warn)

    if args.pan:
        found, entry = is_denied(model, args.pan)
        if found and entry:
            print("[DENIED] " + _fmt_entry(entry))
        else:
            print("[OK] Not in deny list.")

    if args.stats:
        print_stats(model)

    if args.export_csv:
        write_csv(args.export_csv, model)
        print(f"[OK] exported CSV -> {args.export_csv}")

    if args.export_json:
        write_json(args.export_json, model)
        print(f"[OK] exported JSON -> {args.export_json}")

    if args.list:
        print(f"# Reasons ({len(model.reasons)}):")
        for rid, label in sorted(model.reasons.items()):
            print(f"- {rid}: {label}")
        print(f"\n# Entries ({len(model.entries_by_pan)}):")
        for pan, entry in sorted(model.entries_by_pan.items()):
            print(_fmt_entry(entry))

    # default (ไม่มี flag) จะไม่พิมพ์อะไรนอกจาก pan check; คงพฤติกรรมตาม flag


if __name__ == "__main__":
    main()
